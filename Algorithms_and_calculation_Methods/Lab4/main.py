import flet as ftimport mathimport matplotlib.pyplot as pltimport numpy as npimport ioimport base64def main(page: ft.Page):    page.title = "Метод хорд для розв'язання рівнянь"    page.theme_mode = ft.ThemeMode.LIGHT    page.window_width = 900    page.window_height = 700    page.padding = 20    page.scroll = ft.ScrollMode.AUTO    equation = "2*math.log10(x) - x/2 + 1"    a_input = ft.TextField(label="Початок інтервалу (a)", value="0.1", width=150)    b_input = ft.TextField(label="Кінець інтервалу (b)", value="10", width=150)    epsilon_input = ft.TextField(label="Точність (ε)", value="0.0001", width=150)    result_text = ft.Text("", size=16, weight=ft.FontWeight.BOLD)    iterations_text = ft.Text("", size=14)    function_plot = ft.Image(width=900, height=500, visible=False)    process_info = ft.Column([], scroll=ft.ScrollMode.AUTO)    def evaluate_function(expr, x):        try:            return eval(expr, {'__builtins__': None, 'math': math}, {'x': x})        except:            return None    def find_sign_changes(a, b, step=0.01):        intervals = []        x = a        while x < b:            x_next = x + step            f_x, f_x_next = evaluate_function(equation, x), evaluate_function(equation, x_next)            if f_x is not None and f_x_next is not None and f_x * f_x_next < 0:                intervals.append((x, x_next))            x = x_next        return intervals    def chord_method(a, b, epsilon):        def f(x):            return evaluate_function(equation, x)        if f(a) * f(b) >= 0:            return None, []        k = 0        history = []        while abs(b - a) > epsilon:            x_new = a - (f(a) * (b - a)) / (f(b) - f(a))            history.append({'iteration': k, 'x': x_new})            if abs(f(x_new)) < epsilon:                return x_new, history            if f(a) * f(x_new) < 0:                b = x_new            else:                a = x_new            k += 1        return (a + b) / 2, history    def generate_plot(a, b, roots, history=None):        def f(x):            return evaluate_function(equation, x)        x_vals = np.linspace(a - 0.5, b + 0.5, 400)        y_vals = [f(x) for x in x_vals]        plt.figure(figsize=(9, 5))        plt.plot(x_vals, y_vals, label=f"f(x) = {equation}")        plt.axhline(0, color='black', linewidth=0.5)        for root in roots:            plt.axvline(root, color='red', linestyle='--', alpha=0.7, label=f'Корінь ≈ {root:.6f}')            plt.scatter([root], [f(root)], color='red')        if history:            chords = [h['x'] for h in history]            plt.scatter(chords, [f(x) for x in chords], color='green', marker='x', label='Метод хорд')        plt.title("Графік функції та процес знаходження коренів")        plt.xlabel("x")        plt.ylabel("f(x)")        plt.legend()        plt.grid(True)        buf = io.BytesIO()        plt.savefig(buf, format='png', dpi=100)        buf.seek(0)        plt.close()        return buf    def chord_method_click(e):        try:            process_info.controls.clear()            function_plot.visible = False            a = float(a_input.value)            b = float(b_input.value)            epsilon = float(epsilon_input.value)            if a >= b or epsilon <= 0:                result_text.value = "Помилка: некоректні межі інтервалу або точність"                page.update()                return            sign_change_intervals = find_sign_changes(a, b)            if not sign_change_intervals:                result_text.value = "Помилка: Не знайдено змін знаку функції в заданому інтервалі"                page.update()                return            roots = []            all_history = []            for interval in sign_change_intervals:                root, history = chord_method(interval[0], interval[1], epsilon)                if root is not None:                    roots.append(root)                    all_history.extend(history)                    process_info.controls.append(                        ft.Text(f"Інтервал: ({interval[0]:.4f}, {interval[1]:.4f}) → Корінь: {root:.6f}"))            result_text.value = f"Знайдені корені: {', '.join(f'{r:.8f}' for r in roots)}"            iterations_text.value = f"Кількість знайдених коренів: {len(roots)}"            plot_buffer = generate_plot(a, b, roots, all_history)            function_plot.src_base64 = base64.b64encode(plot_buffer.read()).decode("utf-8")            function_plot.visible = True        except Exception as ex:            result_text.value = f"Помилка: {str(ex)}"            iterations_text.value = ""            function_plot.visible = False        page.update()    calculate_button = ft.ElevatedButton(        "Знайти корені",        on_click=chord_method_click,        icon=ft.Icons.CALCULATE,        width=200    )    page.add(        ft.Column([            ft.Text("Автор: \n   Рибачок Михайло Володимирович \n   ІО-34 Варіант 17 \n  Лабораторна робота 4\n",                    size=24,                    weight=ft.FontWeight.BOLD, color="black"),            ft.Divider(),            ft.Text("Розв'язання нелінійних рівнянь методом хорд", size=20, weight=ft.FontWeight.BOLD),            ft.Row([a_input, b_input, epsilon_input], spacing=10),            calculate_button,            ft.Divider(),            result_text,            iterations_text,            ft.Text("Процес розрахунку:", size=16, weight=ft.FontWeight.BOLD),            process_info,            function_plot        ], spacing=15)    )if __name__ == "__main__":    ft.app(target=main)