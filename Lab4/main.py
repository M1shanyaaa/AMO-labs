import flet as ftimport mathimport matplotlib.pyplot as pltimport numpy as npimport iodef main(page: ft.Page):    page.title = "Комбінований метод (хорд та дотичних)"    page.theme_mode = ft.ThemeMode.LIGHT    page.window_width = 900    page.window_height = 700    page.padding = 20    page.scroll = ft.ScrollMode.AUTO    # Елементи інтерфейсу    equation_input = ft.TextField(        label="Рівняння (використовуйте 'x' як змінну)",        value="x**3 - 2*x + 7",        width=400    )    a_input = ft.TextField(label="Початок інтервалу (a)", value="-3", width=150)    b_input = ft.TextField(label="Кінець інтервалу (b)", value="0", width=150)    epsilon_input = ft.TextField(label="Точність (ε)", value="0.0001", width=150)    result_text = ft.Text("", size=16, weight=ft.FontWeight.BOLD)    iterations_text = ft.Text("", size=14)    function_plot = ft.Image(width=1200, height=600, visible=False)    process_info = ft.Column([], scroll=ft.ScrollMode.AUTO)    def evaluate_function(expr, x):        try:            return eval(expr, {'__builtins__': None, 'math': math}, {'x': x})        except:            return None    def derivative(f, x, h=1e-5):        return (f(x + h) - f(x - h)) / (2 * h)    def second_derivative(f, x, h=1e-5):        return (f(x + h) - 2 * f(x) + f(x - h)) / (h * h)    def generate_plot(equation, a, b, root, history=None):        def f(x):            return evaluate_function(equation, x)        x_vals = np.linspace(a - 0.5, b + 0.5, 400)        y_vals = [f(x) for x in x_vals]        plt.figure(figsize=(10, 6))        plt.plot(x_vals, y_vals, label=f"f(x) = {equation}")        plt.axhline(0, color='black', linewidth=0.5)        plt.axvline(root, color='red', linestyle='--', alpha=0.7, label=f'Корінь ≈ {root:.6f}')        plt.scatter([root], [f(root)], color='red')        if history:            chords = [h['chord'] for h in history]            tangents = [h['tangent'] for h in history]            plt.scatter(chords, [f(x) for x in chords], color='green', marker='x', label='Метод хорд')            plt.scatter(tangents, [f(x) for x in tangents], color='blue', marker='o', label='Метод дотичних')        plt.title("Графік функції та процес знаходження кореня")        plt.xlabel("x")        plt.ylabel("f(x)")        plt.legend()        plt.grid(True)        # Зберігаємо графік у буфер        buf = io.BytesIO()        plt.savefig(buf, format='png', dpi=100)        buf.seek(0)        plt.close()        return buf    def combined_method_click(e):        try:            # Очищаємо попередні результати            process_info.controls.clear()            function_plot.visible = False            # Отримуємо вхідні дані            equation = equation_input.value            a = float(a_input.value)            b = float(b_input.value)            epsilon = float(epsilon_input.value)            # Визначаємо функцію            def f(x):                return evaluate_function(equation, x)            if f(a) is None or f(b) is None:                raise ValueError("Невірний формат рівняння")            # Перевірка умови f(a)*f(b) < 0            if f(a) * f(b) >= 0:                result_text.value = "Помилка: f(a) та f(b) мають однаковий знак"                page.update()                return            k = 0            x_chord = a            x_tangent = b            history = []            # Визначаємо поведінку функції            x_test = (a + b) / 2            f_prime = derivative(f, x_test)            f_double_prime = second_derivative(f, x_test)            process_info.controls.append(                ft.Text(f"Початковий інтервал: [{a:.6f}, {b:.6f}]", size=14))            process_info.controls.append(                ft.Text(f"f'({x_test:.3f}) = {f_prime:.3f}, f''({x_test:.3f}) = {f_double_prime:.3f}", size=14))            if f_prime * f_double_prime > 0:                process_info.controls.append(                    ft.Text("Випадок 1: f'*f'' > 0 (хорда - лівий кінець, дотична - правий)", size=14))                while abs(x_tangent - x_chord) > epsilon:                    # Метод хорд (рухомий кінець a)                    x_chord = a - (f(a) * (b - a)) / (f(b) - f(a))                    # Метод дотичних (рухомий кінець b)                    x_tangent = b - f(b) / derivative(f, b)                    # Додаємо до історії                    history.append({                        'iteration': k,                        'chord': x_chord,                        'tangent': x_tangent,                        'interval': (a, b)                    })                    # Оновлюємо інтервал                    a = x_chord                    b = x_tangent                    k += 1                    process_info.controls.append(                        ft.Text(f"Ітерація {k}: хорда = {x_chord:.6f}, дотична = {x_tangent:.6f}", size=12))            else:                process_info.controls.append(                    ft.Text("Випадок 2: f'*f'' < 0 (хорда - правий кінець, дотична - лівий)", size=14))                while abs(x_tangent - x_chord) > epsilon:                    # Метод хорд (рухомий кінець b)                    x_chord = b - (f(b) * (b - a)) / (f(b) - f(a))                    # Метод дотичних (рухомий кінець a)                    x_tangent = a - f(a) / derivative(f, a)                    # Додаємо до історії                    history.append({                        'iteration': k,                        'chord': x_chord,                        'tangent': x_tangent,                        'interval': (a, b)                    })                    # Оновлюємо інтервал                    a = x_tangent                    b = x_chord                    k += 1                    process_info.controls.append(                        ft.Text(f"Ітерація {k}: хорда = {x_chord:.6f}, дотична = {x_tangent:.6f}", size=12))            # Результат - середнє між двома наближеннями            root = (x_chord + x_tangent) / 2            result_text.value = f"Знайдений корінь: {root:.8f}"            iterations_text.value = f"Кількість ітерацій: {k}"            # Генеруємо графік            plot_buffer = generate_plot(equation, float(a_input.value), float(b_input.value), root, history)            function_plot.src_base64 = base64.b64encode(plot_buffer.read()).decode("utf-8")            function_plot.visible = True        except Exception as ex:            result_text.value = f"Помилка: {str(ex)}"            iterations_text.value = ""            function_plot.visible = False        page.update()    # Кнопка розрахунку    calculate_button = ft.ElevatedButton(        "Знайти корінь",        on_click=combined_method_click,        icon=ft.icons.CALCULATE,        width=200    )    # Розміщення елементів на сторінці    page.add(        ft.Column([            ft.Text("Розв'язання нелінійних рівнянь комбінованим методом",                    size=20, weight=ft.FontWeight.BOLD),            ft.Row([equation_input]),            ft.Row([a_input, b_input, epsilon_input]),            calculate_button,            ft.Divider(),            result_text,            iterations_text,            ft.Text("Процес розрахунку:", size=16, weight=ft.FontWeight.BOLD),            ft.Container(                process_info,                height=150,                padding=10,                border=ft.border.all(1, ft.colors.GREY_300),                border_radius=5            ),            function_plot        ], spacing=15)    )# Запуск програмиif __name__ == "__main__":    import base64    ft.app(target=main)